{
  "hash": "edf743af5a6a1b5f9c8f1dba36fd2b1e",
  "result": {
    "markdown": "# Biased Transmission 1 {#sec-biased-transmission-direct}\n\n**This notebook looks at *trait-based copying,* often called \"direct\" or \"content\" bias. This is also often called *cultural selection.***\n\n*Note. All quotations come from [here](https://bookdown.org/amesoudi/ABMtutorial_bookdown/model3.html).*\n\nIn this notebook I also replace loops entirely with [functional programming](https://adv-r.hadley.nz/fp.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ntheme_set(theme_light(base_family = \"Amiri\"))\n\nlibrary(future.apply)\nplan(multisession, workers = parallel::detectCores() - 1L)\n```\n:::\n\n\nAs in @sec-unbiased-transmission and @sec-mutation, we assume two traits $(A, B)$. Let's further assume that biased transmission favors $A$ (perhaps it's \"a more effective tool, more memorable story, or more easily pronounced word\").\n\n> We're not including any mutation in the model, so we need to include some $A$s at the beginning of the simulation otherwise it would never appear. However, let's make it initially rare. Then we can see how selection favors this initially-rare trait.\n\nFor each $t$, each agent choose another agent from the previous generation at random. If that chosen agent has $A$, then the focal agent copies $A$ with probability $s$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBiasedTransmission <- function(\n    N,     # number of agents,\n    s,     # transmission probability,\n    p_0,   # initial proportion of trait \"A\"\n    t_max  # number of generations\n  ) {\n  \n  agent <- sample(c(\"A\", \"B\"), size = N, replace = TRUE, prob = c(p_0, 1-p_0))\n  \n  agent_list <- purrr::accumulate(\n    .x = 2:t_max, ## this sequence gets discarded with the ... in the function call\n    .init = agent, \n    .f = function(agent, ...) {\n      \n      previous_agent <- agent\n      # for each agent, pick a random agent from the previous generation\n      # as demonstrator and store their trait\n      demonstrator_trait <- sample(previous_agent, N, replace = TRUE)\n      # get N random numbers each between 0 and 1\n      copy <- runif(N)\n      # if demonstrator has A and with probability s, copy A from demonstrator\n      agent[demonstrator_trait == \"A\" & copy < s] <- \"A\" \n      return(agent)\n  })\n  \n  p <- purrr::map_dbl(agent_list, function(agent) sum(agent == \"A\") / N)\n  return(p)\n}\n```\n:::\n\n\nWe also use the same helper functions used in @sec-mutation: `rerun_parallel` and `plotSimulation`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nrerun_parallel <- function(S, f, ...) {\n  stopifnot(is.function(f))\n  params <- list(...)\n  \n  ## parallel runs\n  require(future.apply)\n  plan(multisession, workers = parallel::detectCores() - 1L)\n  sim <- future_replicate(S, do.call(f, params))\n  colnames(sim) <- paste0(\"run\", 1:S)\n  \n  ## data processing\n  output <- tibble::as_tibble(sim) |> \n    tibble::rowid_to_column(\"generation\") \n  \n  ## adds attributes to output\n  structure(output, params = params, model = deparse(substitute(f)))\n}\n\nplotSimulation <- function(rerun_out) {\n  \n  params <- unlist(attr(rerun_out, \"params\"))\n  param_labels <- paste(paste(names(params), params, sep = \"=\"), collapse = \",   \")\n  \n  avg <- rowMeans(rerun_out |> select(!generation))\n  \n  rerun_out |> \n    pivot_longer(!generation, names_to = \"simulation\", values_to = \"p\") |> \n    ggplot(aes(generation, p)) + \n    geom_line(alpha = 1/10, aes(group = simulation)) + \n    ylim(0, 1) + \n    geom_line( ## average\n      data = tibble(generation = 1:params[[\"t_max\"]], p = avg), \n      color = \"pink\"\n    ) + \n    labs(caption = param_labels, title = attr(rerun_out, \"model\"))\n}\n```\n:::\n\n\nHere, we'll start with a population that has a small number of trait $A$. We will do $p_0 = 0.01$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- rerun_parallel(S = 100, BiasedTransmission, N = 10000, s = 0.1, p_0 = 0.01, t_max = 150)\nplotSimulation(out)\n```\n\n::: {.cell-output-display}\n![](transmission_bias1_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nLet's increase the strength of selection, $s = 0.2$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- rerun_parallel(S = 100, BiasedTransmission, N = 10000, s = 0.2, p_0 = 0.01, t_max = 150)\nplotSimulation(out)\n```\n\n::: {.cell-output-display}\n![](transmission_bias1_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n[MATH EXPLAINER](https://bookdown.org/amesoudi/ABMtutorial_bookdown/model3.html#analytical-appendix-2)\n\n*Note. @henrich2001 links s-shaped diffusion curves to this form of biased cultural transmission.*\n\n#### Exercise {.unnumbered}\n\n1.  Change ss in **BiasedTransmission** to sasa, and add a new parameter sbsb which specifies the probability of an agent copying trait BB from a demonstrator who possesses that trait. Run the simulation to show that the equilibrium value of pp, and the speed at which this equilibrium is reached, depends on the difference between sasa and sbsb. How do these dynamics differ from the muamua and mubmub you implemented in [Model 2](https://bookdown.org/amesoudi/ABMtutorial_bookdown/model2.html#model2) Q5?\n",
    "supporting": [
      "transmission_bias1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}